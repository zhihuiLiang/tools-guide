# 8086架构机器汇编语言
可参考[8086CPU常用寄存器](https://blog.csdn.net/weixin_44756457/article/details/104444573#:~:text=%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Register%EF%BC%89%EF%BC%9ACPU%E5%86%85%E9%83%A8%E7%94%A8%E4%BA%8E%E6%9A%82%E6%97%B6%E5%AD%98%E6%94%BE%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%20%E9%AB%98%E9%80%9F%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83,%E3%80%82%208086%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E5%8F%AF%E5%88%86%E4%B8%BA8%E4%B8%AA%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%884%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C4%E4%B8%AA%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89%EF%BC%8C1%E4%B8%AA%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C1%E4%B8%AA%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A4%E4%B8%AA%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82)
## 寄存器
### 通用寄存器
+ 8086CPU都是16位的，`AX`,`BX`,`CX`,`DX`存放一般性数据，被称为通用寄存器
### 8086寻址方式
+ 段地址×16+偏移地址
### 段寄存器
#### `CS`和`IP`寄存器
当8086CPU访问内存时，由`CS`,`DS`,`SS`,`ES`,4个段寄存器提供内存单元的段地址
+ `CS`和`IP`是CPU中两个最关键的寄存器，指示了CPU当前要读取的地址，`CS`为代码段寄存器，`IP`为指令指针寄存器，每读取一条指令IP自动增加
+ 8086CPU不能采用`move`指令去修改`CS`和`IP`的值，需要采用`jmp`跳转指令去改`CS`,`IP`
    + `jmp` 段地址:偏移地址 
    + `jmp` 某一个合法寄存器:用寄存器值去修改`IP`
#### DS和[address]寄存器
执行`move [...]`指令时，8086CPU自动去`DS`中的数据为内存单元的段地址，再加上`[]`中的偏移地址即为操作的内存地址
#### SS和SP寄存器
8086CPU中，有两个寄存器，段寄存器`SS`和寄存器`SP`,栈顶的段地址存在`SS`中，偏移地址存放在`SP`中，任意时刻`SS`:`SP`指向栈顶元素
## 编写程序
汇编语言中，包含两种指令，一种汇编指令，一种伪指令
+ 伪指令
(1)
```
XXX segment
.
.
.
XXX ends
```
(2)`assume`指令为“假设”，假设某一段寄存器和程序中某一个用`segment...ends`定义的段相关联
## Loop指令
采用`loop`指令来实现循环功能，`CX`中存放循环次数
## CALL和RET指令
### `ret`和`retf`
+ `ret`指令用栈中的数据修改`IP`的内容，从而实现近转移
，执行`ret`相当于`pop IP`
+ `retf`指令用栈中的数据，修改`CS`和`IP`的内容，
相对与`pop IP`和`pop CS`
### `call`指令
`call 标号`（将当前`IP`压栈后，转到标号执行指令），相当于
```
push IP
jmp near ptr 标号
```
## 内中断
对于8086CPU，当CPU内部有下面的情况发生的时候，将产生相应的中断信息。
+ 除法错误
+ 单步执行
+ 执行into指令
+ 执行int指令
## 中断向量表
CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址
## 80x86保护模式及其编程
## 标志寄存器
标志寄存器`EFLAGS`中的系统标志和`IOPL`字段用于控制`I/O`访问、可屏蔽硬件中断、调试、任务切换以及虚拟8086模式
![8086标志寄存器](../pic/8086%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8.png)
## 内存管理寄存器
处理器提供了4个内存管理寄存器GDTR、LDTR、IDTR、TR
### 全局描述表寄存器GDTR
GDTR寄存器中用于存放全局描述表GDT的32位线性基地址和16位表长度值，基地址GDT表中字节0在线性地址空间中的地址，表长度指明GDT表的字节长度值，指令LGDT和SGDT分别用于加载和保护GDTR寄存器的内容
### 中断描述表寄存器IDTR
与GDTR类似，IDRT用于存放中断描述符表IDT的32位线性基地址和16位表长度值，指令LIDT和SIDT分别用于加载和保存IDTR寄存器的内容
### 局部描述符表寄存器LDTR
每个任务的局部描述符表LDT本身也是由GDT中描述符定义个一个内存段，该段中存放着对应任务的代码段和数据段描述符
### 任务寄存器TR
TR寄存器用于存放当前任务TSS段的16段选择符、32位i基地址、16段长度和描述符属性值。它引用GDT表中的一个TSS类型描述符。
### 控制寄存器
控制寄存器用于控制和确定处理器的操作模式以及当前执行任务的特性
+ CR0中含有控制处理器操作模式和状态的系统控制标志
+ CR1保留不用
+ CR2含有导致页错误的线性地址
+ CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器（PDBR）
